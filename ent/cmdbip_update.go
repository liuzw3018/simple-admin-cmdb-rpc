// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/liuzw3018/simple-admin-cmdb-rpc/ent/cmdbip"
	"github.com/liuzw3018/simple-admin-cmdb-rpc/ent/predicate"
)

// CmdbIpUpdate is the builder for updating CmdbIp entities.
type CmdbIpUpdate struct {
	config
	hooks    []Hook
	mutation *CmdbIpMutation
}

// Where appends a list predicates to the CmdbIpUpdate builder.
func (ciu *CmdbIpUpdate) Where(ps ...predicate.CmdbIp) *CmdbIpUpdate {
	ciu.mutation.Where(ps...)
	return ciu
}

// SetUpdatedAt sets the "updated_at" field.
func (ciu *CmdbIpUpdate) SetUpdatedAt(t time.Time) *CmdbIpUpdate {
	ciu.mutation.SetUpdatedAt(t)
	return ciu
}

// SetUser sets the "user" field.
func (ciu *CmdbIpUpdate) SetUser(s string) *CmdbIpUpdate {
	ciu.mutation.SetUser(s)
	return ciu
}

// SetDepartment sets the "department" field.
func (ciu *CmdbIpUpdate) SetDepartment(s string) *CmdbIpUpdate {
	ciu.mutation.SetDepartment(s)
	return ciu
}

// SetMobile sets the "mobile" field.
func (ciu *CmdbIpUpdate) SetMobile(s string) *CmdbIpUpdate {
	ciu.mutation.SetMobile(s)
	return ciu
}

// SetRemark sets the "remark" field.
func (ciu *CmdbIpUpdate) SetRemark(s string) *CmdbIpUpdate {
	ciu.mutation.SetRemark(s)
	return ciu
}

// SetIP sets the "ip" field.
func (ciu *CmdbIpUpdate) SetIP(s string) *CmdbIpUpdate {
	ciu.mutation.SetIP(s)
	return ciu
}

// SetMask sets the "mask" field.
func (ciu *CmdbIpUpdate) SetMask(s string) *CmdbIpUpdate {
	ciu.mutation.SetMask(s)
	return ciu
}

// SetGateway sets the "gateway" field.
func (ciu *CmdbIpUpdate) SetGateway(s string) *CmdbIpUpdate {
	ciu.mutation.SetGateway(s)
	return ciu
}

// SetOnlineTime sets the "online_time" field.
func (ciu *CmdbIpUpdate) SetOnlineTime(t time.Time) *CmdbIpUpdate {
	ciu.mutation.SetOnlineTime(t)
	return ciu
}

// SetOfflineTime sets the "offline_time" field.
func (ciu *CmdbIpUpdate) SetOfflineTime(t time.Time) *CmdbIpUpdate {
	ciu.mutation.SetOfflineTime(t)
	return ciu
}

// SetIsLeisure sets the "is_leisure" field.
func (ciu *CmdbIpUpdate) SetIsLeisure(u uint) *CmdbIpUpdate {
	ciu.mutation.ResetIsLeisure()
	ciu.mutation.SetIsLeisure(u)
	return ciu
}

// SetNillableIsLeisure sets the "is_leisure" field if the given value is not nil.
func (ciu *CmdbIpUpdate) SetNillableIsLeisure(u *uint) *CmdbIpUpdate {
	if u != nil {
		ciu.SetIsLeisure(*u)
	}
	return ciu
}

// AddIsLeisure adds u to the "is_leisure" field.
func (ciu *CmdbIpUpdate) AddIsLeisure(u int) *CmdbIpUpdate {
	ciu.mutation.AddIsLeisure(u)
	return ciu
}

// SetDeviceType sets the "device_type" field.
func (ciu *CmdbIpUpdate) SetDeviceType(s string) *CmdbIpUpdate {
	ciu.mutation.SetDeviceType(s)
	return ciu
}

// SetNillableDeviceType sets the "device_type" field if the given value is not nil.
func (ciu *CmdbIpUpdate) SetNillableDeviceType(s *string) *CmdbIpUpdate {
	if s != nil {
		ciu.SetDeviceType(*s)
	}
	return ciu
}

// Mutation returns the CmdbIpMutation object of the builder.
func (ciu *CmdbIpUpdate) Mutation() *CmdbIpMutation {
	return ciu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ciu *CmdbIpUpdate) Save(ctx context.Context) (int, error) {
	ciu.defaults()
	return withHooks(ctx, ciu.sqlSave, ciu.mutation, ciu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ciu *CmdbIpUpdate) SaveX(ctx context.Context) int {
	affected, err := ciu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ciu *CmdbIpUpdate) Exec(ctx context.Context) error {
	_, err := ciu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ciu *CmdbIpUpdate) ExecX(ctx context.Context) {
	if err := ciu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ciu *CmdbIpUpdate) defaults() {
	if _, ok := ciu.mutation.UpdatedAt(); !ok {
		v := cmdbip.UpdateDefaultUpdatedAt()
		ciu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ciu *CmdbIpUpdate) check() error {
	if v, ok := ciu.mutation.Mobile(); ok {
		if err := cmdbip.MobileValidator(v); err != nil {
			return &ValidationError{Name: "mobile", err: fmt.Errorf(`ent: validator failed for field "CmdbIp.mobile": %w`, err)}
		}
	}
	return nil
}

func (ciu *CmdbIpUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := ciu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(cmdbip.Table, cmdbip.Columns, sqlgraph.NewFieldSpec(cmdbip.FieldID, field.TypeUint64))
	if ps := ciu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ciu.mutation.UpdatedAt(); ok {
		_spec.SetField(cmdbip.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := ciu.mutation.User(); ok {
		_spec.SetField(cmdbip.FieldUser, field.TypeString, value)
	}
	if value, ok := ciu.mutation.Department(); ok {
		_spec.SetField(cmdbip.FieldDepartment, field.TypeString, value)
	}
	if value, ok := ciu.mutation.Mobile(); ok {
		_spec.SetField(cmdbip.FieldMobile, field.TypeString, value)
	}
	if value, ok := ciu.mutation.Remark(); ok {
		_spec.SetField(cmdbip.FieldRemark, field.TypeString, value)
	}
	if value, ok := ciu.mutation.IP(); ok {
		_spec.SetField(cmdbip.FieldIP, field.TypeString, value)
	}
	if value, ok := ciu.mutation.Mask(); ok {
		_spec.SetField(cmdbip.FieldMask, field.TypeString, value)
	}
	if value, ok := ciu.mutation.Gateway(); ok {
		_spec.SetField(cmdbip.FieldGateway, field.TypeString, value)
	}
	if value, ok := ciu.mutation.OnlineTime(); ok {
		_spec.SetField(cmdbip.FieldOnlineTime, field.TypeTime, value)
	}
	if value, ok := ciu.mutation.OfflineTime(); ok {
		_spec.SetField(cmdbip.FieldOfflineTime, field.TypeTime, value)
	}
	if value, ok := ciu.mutation.IsLeisure(); ok {
		_spec.SetField(cmdbip.FieldIsLeisure, field.TypeUint, value)
	}
	if value, ok := ciu.mutation.AddedIsLeisure(); ok {
		_spec.AddField(cmdbip.FieldIsLeisure, field.TypeUint, value)
	}
	if value, ok := ciu.mutation.DeviceType(); ok {
		_spec.SetField(cmdbip.FieldDeviceType, field.TypeString, value)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, ciu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{cmdbip.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ciu.mutation.done = true
	return n, nil
}

// CmdbIpUpdateOne is the builder for updating a single CmdbIp entity.
type CmdbIpUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *CmdbIpMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (ciuo *CmdbIpUpdateOne) SetUpdatedAt(t time.Time) *CmdbIpUpdateOne {
	ciuo.mutation.SetUpdatedAt(t)
	return ciuo
}

// SetUser sets the "user" field.
func (ciuo *CmdbIpUpdateOne) SetUser(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetUser(s)
	return ciuo
}

// SetDepartment sets the "department" field.
func (ciuo *CmdbIpUpdateOne) SetDepartment(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetDepartment(s)
	return ciuo
}

// SetMobile sets the "mobile" field.
func (ciuo *CmdbIpUpdateOne) SetMobile(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetMobile(s)
	return ciuo
}

// SetRemark sets the "remark" field.
func (ciuo *CmdbIpUpdateOne) SetRemark(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetRemark(s)
	return ciuo
}

// SetIP sets the "ip" field.
func (ciuo *CmdbIpUpdateOne) SetIP(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetIP(s)
	return ciuo
}

// SetMask sets the "mask" field.
func (ciuo *CmdbIpUpdateOne) SetMask(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetMask(s)
	return ciuo
}

// SetGateway sets the "gateway" field.
func (ciuo *CmdbIpUpdateOne) SetGateway(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetGateway(s)
	return ciuo
}

// SetOnlineTime sets the "online_time" field.
func (ciuo *CmdbIpUpdateOne) SetOnlineTime(t time.Time) *CmdbIpUpdateOne {
	ciuo.mutation.SetOnlineTime(t)
	return ciuo
}

// SetOfflineTime sets the "offline_time" field.
func (ciuo *CmdbIpUpdateOne) SetOfflineTime(t time.Time) *CmdbIpUpdateOne {
	ciuo.mutation.SetOfflineTime(t)
	return ciuo
}

// SetIsLeisure sets the "is_leisure" field.
func (ciuo *CmdbIpUpdateOne) SetIsLeisure(u uint) *CmdbIpUpdateOne {
	ciuo.mutation.ResetIsLeisure()
	ciuo.mutation.SetIsLeisure(u)
	return ciuo
}

// SetNillableIsLeisure sets the "is_leisure" field if the given value is not nil.
func (ciuo *CmdbIpUpdateOne) SetNillableIsLeisure(u *uint) *CmdbIpUpdateOne {
	if u != nil {
		ciuo.SetIsLeisure(*u)
	}
	return ciuo
}

// AddIsLeisure adds u to the "is_leisure" field.
func (ciuo *CmdbIpUpdateOne) AddIsLeisure(u int) *CmdbIpUpdateOne {
	ciuo.mutation.AddIsLeisure(u)
	return ciuo
}

// SetDeviceType sets the "device_type" field.
func (ciuo *CmdbIpUpdateOne) SetDeviceType(s string) *CmdbIpUpdateOne {
	ciuo.mutation.SetDeviceType(s)
	return ciuo
}

// SetNillableDeviceType sets the "device_type" field if the given value is not nil.
func (ciuo *CmdbIpUpdateOne) SetNillableDeviceType(s *string) *CmdbIpUpdateOne {
	if s != nil {
		ciuo.SetDeviceType(*s)
	}
	return ciuo
}

// Mutation returns the CmdbIpMutation object of the builder.
func (ciuo *CmdbIpUpdateOne) Mutation() *CmdbIpMutation {
	return ciuo.mutation
}

// Where appends a list predicates to the CmdbIpUpdate builder.
func (ciuo *CmdbIpUpdateOne) Where(ps ...predicate.CmdbIp) *CmdbIpUpdateOne {
	ciuo.mutation.Where(ps...)
	return ciuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ciuo *CmdbIpUpdateOne) Select(field string, fields ...string) *CmdbIpUpdateOne {
	ciuo.fields = append([]string{field}, fields...)
	return ciuo
}

// Save executes the query and returns the updated CmdbIp entity.
func (ciuo *CmdbIpUpdateOne) Save(ctx context.Context) (*CmdbIp, error) {
	ciuo.defaults()
	return withHooks(ctx, ciuo.sqlSave, ciuo.mutation, ciuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ciuo *CmdbIpUpdateOne) SaveX(ctx context.Context) *CmdbIp {
	node, err := ciuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (ciuo *CmdbIpUpdateOne) Exec(ctx context.Context) error {
	_, err := ciuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ciuo *CmdbIpUpdateOne) ExecX(ctx context.Context) {
	if err := ciuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ciuo *CmdbIpUpdateOne) defaults() {
	if _, ok := ciuo.mutation.UpdatedAt(); !ok {
		v := cmdbip.UpdateDefaultUpdatedAt()
		ciuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ciuo *CmdbIpUpdateOne) check() error {
	if v, ok := ciuo.mutation.Mobile(); ok {
		if err := cmdbip.MobileValidator(v); err != nil {
			return &ValidationError{Name: "mobile", err: fmt.Errorf(`ent: validator failed for field "CmdbIp.mobile": %w`, err)}
		}
	}
	return nil
}

func (ciuo *CmdbIpUpdateOne) sqlSave(ctx context.Context) (_node *CmdbIp, err error) {
	if err := ciuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(cmdbip.Table, cmdbip.Columns, sqlgraph.NewFieldSpec(cmdbip.FieldID, field.TypeUint64))
	id, ok := ciuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "CmdbIp.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := ciuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, cmdbip.FieldID)
		for _, f := range fields {
			if !cmdbip.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != cmdbip.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := ciuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ciuo.mutation.UpdatedAt(); ok {
		_spec.SetField(cmdbip.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := ciuo.mutation.User(); ok {
		_spec.SetField(cmdbip.FieldUser, field.TypeString, value)
	}
	if value, ok := ciuo.mutation.Department(); ok {
		_spec.SetField(cmdbip.FieldDepartment, field.TypeString, value)
	}
	if value, ok := ciuo.mutation.Mobile(); ok {
		_spec.SetField(cmdbip.FieldMobile, field.TypeString, value)
	}
	if value, ok := ciuo.mutation.Remark(); ok {
		_spec.SetField(cmdbip.FieldRemark, field.TypeString, value)
	}
	if value, ok := ciuo.mutation.IP(); ok {
		_spec.SetField(cmdbip.FieldIP, field.TypeString, value)
	}
	if value, ok := ciuo.mutation.Mask(); ok {
		_spec.SetField(cmdbip.FieldMask, field.TypeString, value)
	}
	if value, ok := ciuo.mutation.Gateway(); ok {
		_spec.SetField(cmdbip.FieldGateway, field.TypeString, value)
	}
	if value, ok := ciuo.mutation.OnlineTime(); ok {
		_spec.SetField(cmdbip.FieldOnlineTime, field.TypeTime, value)
	}
	if value, ok := ciuo.mutation.OfflineTime(); ok {
		_spec.SetField(cmdbip.FieldOfflineTime, field.TypeTime, value)
	}
	if value, ok := ciuo.mutation.IsLeisure(); ok {
		_spec.SetField(cmdbip.FieldIsLeisure, field.TypeUint, value)
	}
	if value, ok := ciuo.mutation.AddedIsLeisure(); ok {
		_spec.AddField(cmdbip.FieldIsLeisure, field.TypeUint, value)
	}
	if value, ok := ciuo.mutation.DeviceType(); ok {
		_spec.SetField(cmdbip.FieldDeviceType, field.TypeString, value)
	}
	_node = &CmdbIp{config: ciuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, ciuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{cmdbip.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	ciuo.mutation.done = true
	return _node, nil
}
